--- 
title: "CRDMA Guides and Reports"
author:
- affiliation: CRMDA
  description: Director
  email: pauljohn@ku.edu
  name: Paul Johnson
output:
  pdf_document:
    fig_caption: true
    keep_tex: true
    latex_engine: pdflatex
    highlight: haddock
    citation_package: natbib
    pandoc_args: [
        --listings
    ]
    template: theme/crmda-boilerplate.tex
    fontsize: 12pt
preamble:
- \usepackage{xcolor}
- \usepackage{amsmath}
- \usepackage{amssymb}
- \usepackage{fancybox}
- \usepackage{calc}
tables: yes
keywords: guides, report, pandoc, sweave, knitr
---


```{r setup, include=FALSE}
##This Invisible Chunk is required in all CRMDA documents
outdir <- paste0("tmpout")
if (!file.exists(outdir)) dir.create(outdir, recursive = TRUE)
knitr::opts_chunk$set(echo=TRUE,
          comment=NA, fig.path=paste0(outdir, "/p-"))
options(width = 70)
```

Abstract

This document discusses practical problems with preparation of
technical reports and software guides.  The array of settings may seem
to be overwhelming because there are two formats in which documents
can be prepared, noweb/\LaTeX\ and R markdown (the so-called
"frontends"), two code-chunk processing engines, Sweave and knitr, and
two final output formats, PDF and HTML (the so-called "backends"). In
addition, there are style considerations that differentiate technical
reports and software guides.

This is an R markdown document that uses `knitr` to render R code
chunks. It uses `pandoc` and `pdflatex` as compilers for intermediate
versions of the document. In our vernacular, it is an "rmd2pdf-report"
document. As such, it illustrates some tools that work well in R
markdown documents intended for eventual presentation in PDF
documents. Separate documents will be prepared to illustrate the same
features to be obtained in documents prepared with noweb/\LaTeX
documents and R markdown documents that are compiled into HTML.


# Introduction: Terminology

## Guides versus reports

A *guide* \textbf{guide} is intended for students or other
learners. It is not a format suitable for reports to clients or
journal articles. A guide will generally include code and output
excerpts. Preferrably, the code examples will have line numbers. Code
sections will be visually distinct, possibly with syntactical
highlighting.

A *report* is a more formal document. A report is more similar in
style to a journal article or a technical report than a guide. A
report has less code and almost never will it include "raw output"
from a computer program.  A report includes closer-to-publishable
tables and figures.


## Backends and frontends

The term **backend** refers to the format of the final presentation of a
document. It is the deliverable format, the end product.

\begin{quote}
In the CRMDA, we are focused on the generation of documents in
PDF or HTML formats.
\end{quote}

The term **frontend** refers to the document format that we edit. For
example, if one uses Microsoft Word as the frontend, one can export to
various backends.

> In the CRMDA, the frontends on which we concentrate are LaTeX and
> markdown.

The backend for reports is always PDF, never HTML. The backend for
guides might be either PDF nor HTML, depending on the taste of the
author.

## `crmda` package document templates

In the `crmda` package for R, we have report templates. 

The backend for guides can be either HTML or PDF. The frontend can be
either Rmarkdown (suffix \*.Rmd) or a noweb file (suffix \*.Rnw).  A
noweb file has code chunks embedded in it. Noweb files are nearly the
same as \LaTeX, but they have extra markup sections that need to be
revised for presentation.  Noweb documents can be prepared with [LyX](http://www.lyx.org),
which I enjoy, but they also can be written with any ordinary text editor.

At the moment, these are the available choices for input and output,
along with the intended document type and the code-chunk processing engine.

1. Guides
    + rmd2html-guide
    + rnw2pdf-guide-knit
    + rnw2pdf-guide-sweave
2. Reports 
    + rmd2pdf-report
    + rnw2pdf-report-knit
    + rnw2pdf-report-sweave

## Multi-stage document compilation.

Several steps are necessary to convert a document from the frontend to
the backend.  The first step, converts embedded data analysis code
into results and creates a new files, a document in which the analysis
results are embedded (in place of the code). The second step is
"rendering", which produces either PDF or HTML.

A noweb file is converted from Rnw into PDF by a sequence of
transitions.

1. Rnw -> tex.  This is called "weaving" or "knitting". R finds the
   code in the Rnw file and inserts results into a new LaTeX file. The
   difference between weaving and knitting will be explained below.
2. tex -> pdf.  Usually we use `pdflatex`.

If the document is edited with [LyX](http://www.lyx.org), there is an
implicit step 0,

0. LyX -> Rnw. In the LyX pull down menu system, this is represented
   by Export -> Sweave.

A markdown file is converted from Rmd to HTML by this sequence of
transitions

1. Rmd -> md. The "knitting" process replaces code chunks by R input
   and output, converting the R markdown file into an ordinary
   markdown file.
2. md -> HTML. Currently, most people use the program pandoc for
   this. `pandoc` is distributed with Rstudio for the
   convenience of users, but that is not without problems. Users can
   install pandoc and it can be used instead.

The production of PDF from markdown, involves an additional
transition. The first is the same.

1. Rmd -> md. Knitting converts code chunks into R input and output.
2. md -> tex. A LaTeX file is created by `pandoc`. In the header of
   the document, one can set "keep_tex: yes" (as we do here) in order
   to review this intermediate step.
3. tex -> pdf. The default is `pdflatex` for this step, but the
   alternative `xelatex` is growing in popularity because it more
   gracefully handles Unicode characters (utf8). If you are not aware
   of this fact, it may be important to know that a \LaTeX\ document
   may need to be run through `pdflatex` several times because
   cross-references among pages and equations need to be made
   consistent.

The R packages `rmarkdown` and `knitr` orchestrate the process that
builds the instructions to `pandoc`. In rmarkdown, the function render
orchestrates all of the work.  It calls either knitr or Sweave to
handle the code chunks, and it then generates a markdown document. The
markdown document must then be converted into either pdf or HTML. The
`render` function has arguments to specify templates and other style
elements.

## Avoiding compilation trouble

The document production phase can fail at many steps. Errors in
embedded code or document formatting may be difficult to correct
because there are several conversions.

While editing a document, authors are well advised to heed the advice
that applies for LaTeX documents:

\begin{quote}
\textbf{Compile early, compile often!}
\end{quote}

Because I am a very literate person, I would like to share with you a poem:

\begin{quote}
Markdown documents intended for HTML allow some \LaTeX\ code.\\
Markdown documents intended for PDF allow more \LaTeX\ code.\\
The allowed \LaTeX\ code is not the same and\\
neither are the same results obtained by equivalent methods.
\end{quote}

Because no great poet ever stopped after one poem, here is the sequel

\begin{quote}
Almost all HTML code is tolerated well in a Markdown document intended
for HTML.\\
No HTML code is tolerated in a document compiled into a PDF document.\\
When HTML code fails in Rmarkdown, `pandoc` is the usual culprit.
\end{quote}

Inspecting the intermediate files is often a good way to understand
what is going wrong.

Because the document translation software `pandoc` plays a critical
role in the conversion of documents, the documentation for pandoc will
sometimes give us hints about what is going wrong.  Along those lines,
we point readers to the (Pandoc Markdown reference
manual)[http://rmarkdown.rstudio.com/authoring_pandoc_markdown.html]. at
the Rstudio website.



The error messages from compilation are not always helpful. The best
way to understand errors is to detect them as soon as they are
created. Compiling the document frequently is the best way to find out
what works, and what does not.

Another bug-tracking strategy is to inspect the intermediate files
that are created during the rendering process.  This document includes
the header argument `keep_tex: true`, which means we save a copy of
"crmda-reports_and_guides.tex".

One problem worth mentioning is each backend format allows usage of
special features that are not compatible with the other
backends. Because I know this document will be created as PDF, I can
insert a greater amount of \LaTeX\ code than I could in a document
intended for HTML.  Customization of a document for the backend makes
it difficult to re-design a document for a different
backend. Accidental inclusion of features intended for one format in a
document that ends up with a different backend may result in failure
to compile or poor output.

While developing this document, some of the problems with
backend-specific code have come to the forefront.  The HTML backend
allows pleasant color-coded section headings which included in the PDF
output. Tables that work well in PDF documents don't
work in HTML, and vice versa.  Some HTML tables that are legal HTML
don't cooperate with `pandoc`. 

It is also worth mentioning that error messages are not always
informative. In fact, we sometimes don't get error messages when we
should. Rather, we simply receive bad output.  While developing this
document I noticed that when a user includes erroneous \LaTeX\ code in
a markdown document, a flawed HTML output is generated without error
or warning.  On the other hand, changing the intended backend to PDF
causes the compiler to fail and issue an error message. If one is
exporting to HTML, then, a very careful proofreading of the output to
check conversion of \LaTeX\ code into HTML is necessary.

## Let us manage defaults for you

The `crmda` package has settings that work for our documents. These
can be customized, as illustrated in the build script, `rmd2pdf.sh`
that is kept with this document.

Because the number of formats among which `pandoc` can convert is
truly immense, and the number of options for each format is immense,
we expect that there are many details to be attended to.  When I'm
producing the PDF for this document, the `pandoc` command is
elaborate.

> $ /usr/bin/pandoc +RTS -K512m -RTS crmda-reports_and_guides.utf8.md
> --to latex --from
> markdown+autolink_bare_uris+ascii_identifiers+tex_math_single_backslash
> --table-of-contents --toc-depth 2 --template
> theme/crmda-boilerplate.tex --highlight-style haddock --latex-engine 
> pdflatex --listings
 
The Rstudio team, the authors of the packages `rmarkdown` and `knitr`,
and the program `pandoc` have created a family of settings and default
styles that work for their purposes. In the `crmda` package, we have
customized document templates and style sheets that override some of
their decisions.  The functions `rmd2html` and `rmd2pdf` are "wrappers"
that apply our organizational strategy. We will have more detail about
that below.

## When choosing the frontend, consider the backend

The choice among frontends, either \LaTeX\ or markdown, depends on
several considerations.  A first major consideration in choosing a
frontend is, oddly enough, the intended output format of the backend.

> If one intends to export as HTML, then markdown is, *by far*, the most
> reasonable choice for a frontend. 

\LaTeX\ is primarily intended for the creation of publication-quality
documents in PDF format. Conversion from \LaTeX\ to HTML is less
decidedly less unsatisfactory.

> If one intends to export to PDF, then markdown or \LaTeX\ can
> be useful. But \LaTeX\ is probably better.

Markdown documents can be used to generate HTML or PDF. In some sense,
the format is flexible. As long as no PDF-specific features are
used--all document elements are compatible with PDF or HTML
output--then it is not difficult to change from one backend to
another.

While it sounds like good news that a vanilla document can be easily
adapted to compile into HTML or PDF, one hastens to point out almost
no useful document will confine themselves to the vanilla components.
Generally speaking, a markdown document that uses special
HTML-oriented features will not be readily turned into PDF. The
converse is also true. 

Having dispensed, then, with the idea that markdown can be used to
easily produce either format, the question becomes, "if we are to
produce PDF, should we use markdown or \LaTeX?"  If the end result
should be a PDF document, it seems certain to me that the author who
uses \LaTeX\ will have a more satisfactory result.

For novices, \LaTeX\ is more difficult. Perhaps this is not such a big
hurdle as it used to be because [LyX](http://www.lyx.org) is
available.

If I were using Rstudio, I'd be able to edit documents intended to be
compiled into PDF via Sweave or knitr, and I could also create
markdown documents. For may beginners, then, Rstudio seems to be a
place to start. But there are some bad features in Rstudio that lead
me to be cautious. 

The most serious problem with Rstudio is that it alters the document
header without warning the author. If one opens our Rmarkdown template
`rmd2pdf-report` in Rstudio, and then chooses "knit to HTML" and then
"knit to PDF", Rstudio will have destroyed the document header
entirely.  The CRMDA style elements will have been obliterated because
Rstudio unceremoniously replaces them. I believe this is a user
interface design flaw in Rstudio.

## Where we have been

In order to embrace the importance of using either markdown or \LaTeX,
one must first abandon the idea that Microsoft Word can ever be useful
for serious authorship. That's a big step for many graduate students
and professors.

If we look past GUI "what you see is what you get" (*wyswig*) word
processors, where do we go? For a long time, the only answer was
\LaTeX. However, there was a fatal weakness in \LaTeX. It is intended
for PDF output, not Web pages. Exports into HTML were
problematic. \LaTeX\ was not only difficult for some to use, but it
also did not benefit from fancy features that were becomming available
in the Internet, especially cascading style sheets and Javascript.

This gap in the document production process created a need for a new
methods. In the 1990s, there was quite a bit of effort to make user
friendly Web page editors, so that authors could have a Word-like
experience that would generate HTML. The end result, generally, was
difficult-to-maintain HTML documents. It was generally not feasible to
edit and revise documents, the HTML generated was both extremly
complicated and generally unsatisfactory.

Another strategy was the development of alternative markup languages.
In a way similar to \LaTeX, these markup languages (e.g., `docbook`)
drop the idea that the user should have a *wyswig*
experience. Instead, the author would again become a programmer who
would insert symbols to create sections.

Markdown was developed as a rejection of both ugly markup documents
(either \LaTeX\ or HTML) and *wyswig* editors.  The idea is that
documents should be text files that are readable *as is* but also
convertible into other backends. The "markdown" movement seeks to
deliver an easier-to-edit, less difficult-to-read, and
easier-to-convert format. The leader is John Gruber, whose Website is
boldly named ["daringfireball"](https://daringfireball.net/projects/markdown).

Markdown is intended to be easy-to-read, so that even if it is not
compiled into a backend, it might be presentable to an audience of
non-programmers. That general idea seems unrealistic to me, there is
almost never going to be an audience (for CRMDA, at least), which is
eager to look at a markdown file. The dropback argument is that
a markdown file is more easily produced by a novice who does not want
to learn to use \LaTeX.  This seems more persuasive.

The strength of markdown is that it makes it fairly easy to
produce HTML documents that utilize some (not all) of the strengths of
the World Wide Web's most commonly used method of communication.
Where markdown is not capable, one can still write "raw HTML" in the
middle of a markdown document.

# What do we Really, Really Need?

## Style consistency

All CRMDA reports should have a consistent "look and feel". All
reports should have the organizational logo at the top and contact
information should be evident.  The name of the author, and the date,
must always be included. 

The consistent formatting of reports, whether they are prepared with
LaTeX or markdown, is now a "solved problem." The original style for
CRMDA reports was created by GRAs in 2012 and 2013. Its style began
with the Center stationary (a document that had a KU logo in the
header and an ornate footer with address information).  If we change
the style as produced from \LaTeX\ into PDF, then we need to fix the
template documents and converters for the other formats. Hence, I'm
somewhat reluctant to debate (again!) about the desired format.

The consistent "look and feel" of guide documents is not a "solved
problem."  We had an "old" style for MS Word authors.  We imitated
that for \LaTeX\ users.  But that style was impossible with markdown
documents.  Our HTML documents must fit within a style scheme created
by the university's Drupal style. Beyond the simple
header format, there was not much consistency in presentation of
content. Some of those legacy guides, which were dubbed "KUant
Guides", are still available in
our [CRMDA web page](https://crmda.dept.ku.edu/guides) and, from
time-to-time, we re-format them in a more consistent way.


## Math

We are a Center focused on methodology. It is necessary to be able to
write about math, preferably with a standard, uniform mathematical
markup language, such as \LaTeX.

Many social scientists are not familiar with \LaTeX\ document
preparation. That was a hurdle that kept many authors with Microsoft
Word, even when they were frustrated with it.  The difficulty of using
\LaTeX\ was solved, to a significant extent, by LyX, an open source
graphical interface. With LyX, or other editors that could generate
\LaTeX\ output (such as Scientific Word, TexMacs, or Abiword), authors
who were not computer programmers could learn enough \LaTeX\ to finish
their projects.

For many years, the inability of Web pages to display equations was a
major problem. It was suggested that we make little picture (say, png)
files with equation shapshots and insert them into our Webpages.  That
worked badly, as did the effort to create math markup language for the
Web. A more-or-less workable solution was developed, a framework
called MathJax. MathJax allows inclusion of math markup in the page
which--when the conditions are right--can be converted by the Web
browser to look like equations. 

The MathJax display system works better and better over time; it
*almost always works*. But it does not work if you are offline, or the
MathJax server happens to fail. Users will see markup, rather than
equations, when the network fails. 

I suppose the key point is this. If one wants to put math into a
document, it is 100% sure to display as intended if the backend is
PDF.  With HTML output, math may work, but may not. Because PDF is more
universal, documents that rely heavily on math should use the PDF
backend.

## Literate documents: include code and output

We need to be able to write about computer code. The "old fashioned"
way is to copy/paste code and output into documents.  That's somewhat
error prone and difficult to keep up-to-date.

Donald Knuth, a famous Stanford professor of computer science,
proposed strategies to integrate the production of documents with the
development of computer code.  Rather than creating code in one file,
and documentation in another, the idea was that the two parts of our
work should be blended in a "literate programming" exercise. 

The literate programming idea is more a general way of life than it is
a particular document production strategy. It is, partly, aimed at
programmers who don't like to write instruction manuals. In the end,
however, it may have more impact on non-programmers who need to
prepare technical reports that include computer code examples.

In computer programming, one of the biggest impacts of literate
programming is the proliferation of systems for preparation of
documentation within code files. In the 1990s and early 2000s, when I
was working on the Swarm Simulation System, we used a framework called
Autodoc that allowed us to write instructions into Objective-C code
that were later harvested and turned into instructional manuals. See,
for example, the documentation for the [Opinion Formation model]
(http://pj.freefaculty.org/Swarm/MySwarmCode/OpinionFormation/Opinion-Docs). The
Autodoc program was poorly documented and not easy to get, but soon
after that, a new coding system called Doxygen became widely
available. Doxygen, developed for creation of instruction manuals for
C++ programs, was a major success in computer programming.  Like
Autodoc, Doxygen gave programmers a relatively convenient method to
explain what they were doing without wasting too much time.

In the modern experience of most CRMDA staffers, the "documentation
inside code" approach is visible in the Roxygen markup method used for
functions in R documents. Any function worth using should have Roxygen
markup.


### Enter "code chunks"

> A code chunk is a runable piece of R code. Producing the document
> will re-run calculations.

Suppose a professor is writing about the psychology of adolescence or
social conflict in Uganda. In the "old" paradigm, the professor will
do some statistical analysis in SAS or SPSS and the copy/paste output
into the document. This is a tedious, error prone process. Documents
produced in this way are difficult to keep up-to-date and difficult to
proof read.

Especially in guide documents, it is very helpful to intersperse code
and results. Instead of cutting and pasting, we instead insert code
chunks that are *run during document preparation*. The advantages of
this are obvious.  The statistical code and results never become "out
of step" with the final document.  If the raw data is revised somehow,
we no longer repeat the "old" fashioned process of re-running the
analysis and then "copy/pasting" the results into a revised
document. Instead, we run through the document preparation steps again
and the results are *automatically* updated and revised.

Code chunks are allowed in both noweb/\LaTeX\ and markdown documents
intended for either HTML or PDF. In R, the original method for
creating code is
called ["Sweave"](https://leisch.userweb.mwn.de/Sweave). A code chunk
is created by a somewhat cumbersome notation that begins with "<<>>="
and ends with "@". Here is a code chunk that runs a regression model.

```
<<>>=
lm(y ~ x, data = dat)
@
```

In `Rmarkdown`, the outer boundaries are changed to three back ticks,
along with squiggly braces.

\begin{lstlisting}
`r ''````{r}
lm(y ~ x, data = dat)
`r ''````
\end{lstlisting}

These are simple, unnamed chunks. In actual usage, the beginning of
the chunk usually has several additional arguments, including a name
for the chunk.  Names are helpful because error messages will later
report the name of the failed chunk.  For that reason, we suggest, as
a general policy, that *chunks should be named*.


```
<<mychunk10>>=
lm(y ~ x, data = dat)
@
```

\begin{lstlisting}
`r ''````{r mychunk10}
lm(y ~ x, data = dat)
`r ''````
\end{lstlisting}

The options, which control if the code is displayed in the document,
or if the output is included, and so forth, can be specified after the
chunk's name.

Rather than going through all possible chunk arguments, we now survey
(and give examples) of the chunk variations that we require in CRMDA
documents.  The most vital chores that we need to be able to
accomplish are chunks that:

1. are not evaluated, but are displayed "beautifully" to the reader,
   with syntax highlighting.
2. are not displayed, but are evaluated, and the results may (or may
   not) be displayed for the reader.
3. create graphics, which are automatically included in the document.
4. create graphics (or other files) that are not automatically
   included in the document, but can be inserted at a different part
   in the document
5. import previous chunks for re-analysis



# R code chunks

1. A chunk with commands that are echoed within the document, but not evaluated

```{r chunk10, eval=F}
set.seed(234234)
x <- rnorm(100)
mean(x)
```

2. A chunk that is evaluated, echoed, both input and output

```{r chunk20}
set.seed(234234)
x <- rnorm(100)
mean(x)
```

3. A chunk that is evaluated, with output displayed, but code is not echoed

```{r chunk30, echo=F}
set.seed(234234)
x <- rnorm(100)
mean(x)
```

4. A chunk that is evaluated, but neither is the input nor output displayed:

```{r chunk40, include=F}
set.seed(234234)
x <- rnorm(100)
mean(x)
```
Do you see there was nothing there? After that, we have `x` in the
on-going R session, it can be put to use.

5. A chunk that creates a graph and sizes it with knitr options, but
   the code is not echoed. 

```{r chunk50, fig=T, fig.height=3, fig.width=4, fig.show="hold", echo=F}
hist(x, main = "One Histogram Displayed Inline")
```


6. This is a special feature of the PDF backend. In previous example,
   the figure was placed into the document at the point of the code
   chunk. PDF documents have features for "floating" tables and
   figures and these can be used.  A chunk that creates a graph and
   provides a caption will cause a float to be created. 

```{r chunk60, fig=T, fig.height=3, fig.width=4, fig.show="hold", echo=F, fig.cap = "\\label{fig:hfloat}A Floating Histogram"}
hist(x, main = "One Histogram")
```

Observe in the output we have a numbers, floating figure. Because we
inserted a label with the caption, we can cross-reference Figure
\ref{fig:hfloat}. Figure numbers will be adjusted automatically as new
figures are added before and after this chunk. This feature is not
available in HTML.
   
7. A chunk that creates a graph, but does not display it, but does
show the code that created the graph
 
```{r chunk65, fig=T, fig.height=3, fig.width=4, fig.show="hide", dev=c('png','pdf')}
hist(x, main = "Another Histogram")
```

Why do this? In HTML, we don't have the option to create figure
floats, but the next-best option is to show code for a figure, but
prevent its inclusion in the document by setting `fig.show="hide"`.

In this code chunk, we asked for output in 2 formats, one as png and one as pdf.

Now that the image file exists, we can insert it manually, because the
pdf was saved in a file named "tmpout/p-chunk60-1.pdf". I chose the
name "tmpout" in the template, that is configurable. But I like that
name pretty much. Here, for example, is an HTML table in which I have
embedded that image

If we want to insert the figure with markdown tools, we could. This is
the code that would typically be used.
```
![Another Histogram](tmpout/p-chunk65-1.pdf)
```

This is inflexible because the image cannot be rescaled.  Also, note
that markdown does not have a concept of "centering" or "alignment" of
a figure, so to a significant extent we have to focus on tools in the
backend document language.  Here we suggest using backend-specific
code to include--and scale--the figure. This inserts the figure using
\LaTeX\ terminology in a PDF document__

```
\includegraphics[width=3.5in]{tmpout/p-chunk65-1.pdf}
```

\includegraphics[width=3.5in]{tmpout/p-chunk65-1.pdf}

Here we are happy to see that the *raw \LaTeX* code for inserting
graphics does work (but do not understand why).

If we are targeting an HTML backend, we would write a similar request
in HTML code, using the file `tmpout/p-chunk65-1.png`:

```
<img src="tmpout/p-chunk65-1.png" alt="a floating histogram" width="308"
height = "216">
```

Here, we are guessing that the end user's screen will tolerate an
image that is 308 pixels wide. If I were writing in HTML at the
moment, I'd try harder on sizing that appropriately. But this is a PDF
document and this is just an example of what an HTML author might do.


8. One chunk that shows a series of commands. This is an example of a
   strenght of knitr that is not present in Sweave.  The `knitr` code
   chunk option will . It is possible to display the whole graph created by the
   series of commands.
 
In this case we have the usual R plotting exercise in which a "blank"
plot is created, and then lines, points, and labels are added one by
one.

```{r chunk70, echo=F, include=F}
## alter par, after keeping copy
par.orig <- par(no.readonly = FALSE)
par(xaxs="i", yaxs="i", xpd=FALSE)
```

```{r chunk71, eval=F, echo=TRUE, warning=FALSE, collapse=TRUE}
plot(c(0, 1), c(0, 1), type = "n", ann = FALSE, axes = FALSE)
rect(0, 0, 1, 1, col = "light grey", border = "grey")
mtext(c("Min x", "Max x"), side = 1, line = 1, at = c(0, 1))
mtext(c("Min y", "Max y"), side = 2, line = 1, at = c(0, 1))
lines(c(.6, .6, 0), c(0, .6, .6), lty = "dashed")
text(.6, .6, expression(paste("The location ",
        group("(",list(x[i], y[i]),")"))), pos = 3)
points(.6, .6, pch = 16)
mtext(expression(x[i]), side = 1, at = .6, line = .7)
mtext(expression(y[i]), side = 2, at = .6, line = .7)
```

If we run that code from top to bottom, it produces one figure, which
we display here:

```{r chunk75, ref.label='chunk71', echo=F, fig=T, fig.keep="last", collapse=T, fig.width=5, fig.height=5}
```

However, we might be in teaching mode and we need to demonstrate the
effect of each successive instruction.  The `knitr` option list
includes a parameter `fig.keep`, which we can ask to keep a snapshot of
each stage in the creation of this figure.

```{r chunk76, ref.label='chunk71', echo=F, fig=T, include=F, fig.keep="all", collapse=T, fig.width=4, fig.height=4}
```

A quick check of the tmpout directory shows that this code created several
graphs, named `p-chunk-76-1.pdf` through `p-chunk-76-??.pdf`. The
automatic display of the 16 figures is not terriffic, but it is easy
enough to line them up in a table.

figure begin top left   | continue row-wise
------------------------|-----------------
![a](tmpout/p-chunk76-2.pdf)|![b](tmpout/p-chunk76-5.pdf)
![c](tmpout/p-chunk76-7.pdf)|![d](tmpout/p-chunk76-9.pdf)



```{r chunk79, echo=F, include=F}
par(par.orig)
```





# More about Document Preparation 

## Working with \LaTeX

Like so many other concepts and tools in this area, \TeX was a
creation of Donald Knuth at Stanford. \TeX was the precursor to
\LaTeX.

The CRMDA maintains a Web page about \LaTeX: https://crmda.ku.edu/latex-help

That page has basic guides and information about the KU dissertation
template.

One of the questions not considered in our Web page is the following.

### Should one prefer `Sweave` or `knitr`?

Sweave works with noweb/\LaTeX\ documents--not with markdown
documents. The code chunks for Sweave and knitr are written in the
same format in a noweb document, i.e., with "<<>>=" and "@".  In
Rmarkdown documents, there is no Sweave engine to process chunks, only
`knitr`. Perhaps that suggests that, if one must learn one set of
chunk options, then `knitr` options are the right place to start
(since they can be used in documents intended for HTML or PDF). 

The chunk options allowed the original `Sweave` were `echo` (include
code with output?), `eval` (run the chunk calculations?),
`include` (display the chunk in the document?), `fig` (code generates
a figure?) and `results` (output in \LaTeX\ is handled differently than
raw Tex.  There are a few others, but that is most of the story. `knitr`
honored most of the Sweave options and then added many more(see [knitr
code chunk options](https://yihui.name/knitr/options). A few of
these knitr chunk options are displayed below in Section ??? ???

A \LaTeX\ document prepared with Sweave chunks can be be handled by
`knitr` tools. I prefer to Sweave \LaTeX\ documents, in large part because
\LaTeX\ allows the `split=TRUE` document option. That option creates
separate \*.tex output files for each code chunk.

On the other hand, when preparing an Rmarkdown document, `knitr` is
the only show on the road. I am enjoying the exploration into the
chunk and document options. 

One unanticipated benefit of markdown with knitr is that it is
possible to make documents about other programs (not just R). I've
explored knitr to weave documents about BASH shell programming, for
example.

?? ?? how enter cross section reference in markdown?



## Working with Rmarkdown
	
The CRMDA does not yet have a Web page about using Rmarkdown, so this 
section will serve as an overview.
	
### Use a text editor

An R markdown file is suffixed ".Rmd", *not* ".rmd". It is a "raw
text" file. Don't edit it with MS Word.  Instead, use a programmers
file editor, such as Emacs, Notepad++, or an integrated development
environment, such as Rstudio, to edit the file.

Remember that the markdown philosophy is that a document should look
reasonably nice, even before it is compiled.  That means authors
should take care that their document has reasonably "shaped"
paragraphs. Lines should generally be 80 characters or less.

### Plan for either HTML or PDF output

Although the pull-down menu in Rstudio might make a person think that
it is simple to change the document backend from PDF to HTML, it is a
mistake to believe that.  The special features we used in HTML
documents do not convert gracefully into PDF, and the converse is also
true.  The Rmd file will undergo several conversions before it turns
into the final result and features that are not aligned with the 
backend format are going to cause either errors or poor output.


## Basic Rmarkdown

Some *basic markdown* is compatible with either HTML or PDF
output. These are the most frequently used ones.

1. Character styling. 
    *  *Italics* result from asterixes (`*italics*`)
    *  **bold face** results from two asterixes (`**boldface**`).
    *  `computer code` should be a typewriter fixed width font produced by
    using two "backticks" ($^\backprime \textrm{computer code} ^\backprime$) 
1. Section headers. 
    *  `#` is level 1 header
    *  `##` is level 2 subheading
    *  levels below are used differently in HTML and PDF.  The ability of
   html documents to include specialized subsections is one of the
   advantages of that backend. In markdown, they provide for 6 levels
   of headings.
1. Paragraph styling
    * Paragraphs are created by blank lines
    * Two blank spaces at end of line signify new line without creating new
    paragraph (blank line) below.
    *  Indented material like this:

    >  quotations or other highlighted material (block quotes)

    begins with a $>$ character in column 1, followed by a space:

    \begin{lstlisting}
    > quotations or other highlighted material (block quotes)
    \end{lstlisting}

    * code listings that are not chunks, such as

    ```
    int x = 3
    ```

    are requested by three ticks before and after

    \begin{lstlisting}
    `r ''````
    int x = 3
    `r ''````
    \end{lstlisting}

4. Lists. 
    *  Numbered lists can be created by putting a number in column 1
       of a new line, followed by a space.
    *  Bullet lists can be created by putting an asterix in column 1
       of a new line, followed by a space.
 
    *  Lists can be nested by typing four blank spaces for each level
       of nesting.
    *  Question About lists: how do we insert separate paragraphs
       under list headings and then re-continue the list in Rmarkdown
       ?? ??.

1. Hyperlinks, such as (CRMDA)[https://crmda.ku.edu], for which the
   markdown is `(CRMDA)[https://crmda.ku.edu`
5. Citations. Need to know how to use natbib citations in a markdown
   document ?? ???
	
## Caution about Rmarkdown markup

As these examples indicate, Rmarkdown is similar to, but the exactly
the same, as the
[general markdown specification](https://daringfireball.net/projects/markdown).
It is different from other specialized dialects, such as
the [GitHub Flavored Markdown](https://github.github.com/gfm) and
other variants. Be cautious about using style guides that are not
intended explicitly for Rmarkdown documents. There is a good chance
their advice is irrelevant. Google searches will sometimes lead to the
wrong answer for a particular form of Markdown.
	
	
## Math in Markdown documents

There's a fairly broad range of mathematical markup that will work in
Rmarkdown documents intended for PDF and HTML. 

Here are the highlights.

1. In-line math markup is dollar-sign bracketed, just as in \LaTeX
   itself. We can write `$f_{ij} x_{i} \times y_{j}^2$` for
   $f_{ij} x_{i} \times y_{j}^2$. Using the usual \LaTeX\ format, we
   can write the Greek letters, binary relations, and other important
   symbols. Behold:

\[
   \alpha, \beta, \gamma, \Gamma, \chi, \approx, \ne, \geq, \leq, \pm,
   \sim, \rightarrow, \pi, \textrm{and} \infty.
\]

2. Displayed equations--equations that are centered or otherwise set
apart from the text--should be bracketed by `\[` and `\]`. In \LaTeX,
it is not longer recommended to use the double-dollar sign notation
for displayed equations.  
 
Compare the inline mode, $\bar{x} = \frac{1}{n} \sum_{i=1}^{n}x_{i}$
with the display equation:

\[
\bar{x} = \frac{1}{n} \sum_{i=1}^{n}x_{i}
\]

that results from

```
\[
\bar{x} = \frac{1}{n} \sum_{i=1}^{n}x_{i}
\]
```

One can also use the \LaTeX\ ```\begin{equation}```, which comes from
the \LaTeX\ package *amsmath*.

\begin{equation}
A_{m,n} = \left(\begin{array}{ccc}
a & b & c\\
d & e & f\\
g & h & i\\
\end{array}\right)
\label{eq:another1}
\end{equation}

This is not the right place for a comprehensive guide to \LaTeX.
Users will need to install a \LaTeX\ distribution and then a
user-friendly editor that will help create equation markup.  Many
users in the CRMDA lab use LyX, which offers a "View source" feature
to inspect \LaTeX\ coding for equations.	

 At the current time, we do not know the boundaries of what will work,
but we do know (for sure) that Rmarkdown -> HTML document transition
will ignore \LaTeX\ errors and replace errors with blank spaces.
Hence, when producing HTML output, one should inspect output very
carefully.

## Additional Material about Rmarkdown

1. [*R Markdown Reference Guide*](https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf)
2. [*R Markdown Cheatsheet*](https://www.rstudio.com/wp-content/uploads/2016/03/rmarkdown-cheatsheet-2.0.pdf)
3. Yihui Xie. 2015. *Dynamic Documents with R and Knitr. 2ed* Boca
Raton, Florida: Chapman Hall/CRC. http://yihui.name/knitr.  On July 7,
2017, Xie made available a new book manuscript, [*bookdown: Authoring
Books and Technical Documents with R Markdown*]
(https://bookdown.org/yihui/bookdown).

User-friendly overviews and tutorials on Rmarkdown usage are
available.

1. [*Markdown Basics*](http://rmarkdown.rstudio.com/authoring_basics.html). See
 also the Rmarkdown page at Rstudio corporation, http://rmarkdown.rstudio.com, which offers a  
["Get Started" Tutorial](http://rmarkdown.rstudio.com/lesson-1.html).
2. Cosma Shalizi, "Using R Markdown for Class Reports",
   http://www.stat.cmu.edu/~cshalizi/rmarkdown.
3. Wisconsin University Social Science
   Computing Collaborative. "R for Researchers: R Markdown".  
   http://www.ssc.wisc.edu/sscc/pubs/RFR/RFR_RMarkdown.html
4. Karl Broman, "Knitr with R Markdown".  
   http://kbroman.org/knitr_knutshell/pages/Rmarkdown.html
	
	
# Using the `crmda` Package

The `crmda` package provides templates for several types of documents
using various front and backends.

Here we will illustrate the process of initiating a guide document
that is to be prepared with Rmarkdown and will have the HTML backend.

Start R in a folder where you would like to create a write-up and run

```
> initWriteup("rmd2pdf-report")
```

That does not specify the name of the output directory, so a folder
named "writeup/rmd2pdf-report" will be created in the R current
working directory. That folder should have a copy of the template,
some instructions, and a compiler script.

If I were running this inside an R folder within one of our projects,
I would instead run

```
> initWriteup("rmd2pdf-report", dir = "../writeup")
```

because I want my writeups to collect in the writeup folder of the
project.

The first order of business is to rename the subfolder from
"rmd2pdf-report" to something more memorable.  There may be several
reports for this project. Here I might choose "about_reports" or
similar. This way, every writeup for the project is a self-contained
thing. If I run `initWriteup` again, then the folder and files will be
overwritten, so it is best to rename the writeup subfolder.

Next, we need to make sure the build programs exist.  Open the file
"guide-template.Rmd" in a text editor.  Insert your name or a title
and save the document.  Now try to compile it.
	
The file can be compiled in two ways. 

1. Open an R session and use the function `rmd2pdf()` in the crmda
package.

    For example:
    
    ```
    > library(crmda)
    > rmd2pdf("guide-template.Rmd")
    ```
    
    The `rmd2pdf` function allows other arguments that will
    be passed through to the render and html_document functions in
    the `Rmarkdown` and `knitr` packages for R. This is
    explained in the documentation.

2. Run a shell script provided with the template.

It is not necessary to open R to compile the document. The output can
also be generated by running a command line script that does the same
work.

```
$ ./rmd2pdf.sh guide-template.Rmd
```

The rendered output will be a pdf file

If one uses Rstudio as a text editor for an Rmd file, one may not
obtain satisfactory output by compiling the document with the pull
down menus.

### About the shell scripts

In July, 2017, I decided to change the way that the shell scripts are
designed. Users who inspect them should see the script runs R and
launches functions in the `crmda` package with various settings. The
script `rmd2pdf.sh` is now minimal. There is little more than code to
retrieve a `$filename` from the command line and constuct a string of
arguments that `crmda::rmd2pdf` will sort through. The default
arguments specified in the script are simple, such as,

```
defaults="toc=TRUE, output_dir=\"$pwd\""
```

and the file name, along with defaults, are put to use in a
not-very-subtle way:

``` Rscript -e "library(crmda); rmd2pdf(\"$filename\", $defaults)" ```
The defaults string can be edited to provide new arguments, which will
then end up being passed to the R functions `render` and
`pdf_document` (or `html_document` if we are creating HTML output) in
the `rmarkdown` and `knitr` packages. Any defaults specified in the
script, or in the function call to `rmd2pdf` inside R, will override
the other customizations that I've put in place in the `crmda`
package.

This document is produced with a revised version of the script.
needed to use a slightly altered \LaTeX\ template, and I needed to see
the intermediate files in order to understand some errors and poor
formatting that I saw in early work. My `defaults` string has

```
defaults="toc=TRUE, output_dir=\"$pwd\", clean=FALSE, quiet=FALSE, 
          template=\"theme/crmda-boilerplate.tex\", keep_tex=TRUE"
```

Inside R, using the function `rmd2pdf`, I achieve the same result 
by inserting the arguments into the function call:

```
> rmd2html("guide-template.Rmd", toc=TRUE, output_dir="$pwd", 
          clean=FALSE, quiet=FALSE,
		  template="theme/crmda-boilerplate.tex", 
		  keep_tex=TRUE)
```

The documentation for `rmd2pdf` should be helpful (or will be, eventually).


#### Markup worries.

To produce the same result differs in mardown documents intended for
PDF and HTML

In an Rmarkdown document intended for PDF, one
writes `\LaTeX` to produce \LaTeX. On the other, in a document
intended for HTML, one must insert dollar signs, as in
`$\LaTeX$`. Using the no-dollar-sign method in the document intended
for HTML results in an empty space, but no error message. Using the
dollar-sign version in a document intended for PDF results in a
failure to compile and the error message

\begin{lstlisting}
! You can't use `\spacefactor' in math mode.
\@->\spacefactor
                 \@m {}
l.934 ...to compile and the error message \(\LaTeX

pandoc: Error producing PDF
\end{lstlisting}

Most of the \LaTeX\ markup that we have tested in Rmd files intended
for PDF works well (but not all, for reasons I don't understand
yet). A good deal of the portion of \LaTeX\ that applies to math can be
used within the Rmd file intended for HTML output. I do not currently
understand the boundaries, they are no doubt imposed by the combined
converters of `rmarkdown` and `pandoc`. 



#### Caution
We notice that errors in \LaTeX\ code are ignored by the HTML backend
but the PDF backend gives an error.

#### We need numbered equations

But equation numbers in Rmarkdown intended for HTML are done
differently than Rmarkdown intended for PDF.

#### Math is not incorporated in HTML in the same way as PDF

Compiling a document into PDF uses a program like `pdflatex` to
put the equations "in" the document. They are displayed in (more or
less) the same way on various browsers and operating systems.

The same is not true for math in HTML documents.  Simply put, **math
is not allowed in HTML**. We think it is allowed--our eyes tells us it
is allowed--because we browse Web pages that show equations. However,
this is an illusion achieved by extraordiary measures involving
Javascript and third party servers.  The beautifully formatted \LaTeX
equation is not "embedded" in the HTML, it is instead delivered as
code "available for rendering" in the Web browser. The HTML code is
converted, via javascript and functions supplied interactively from
the MathJax Web server. 

#### Markdown to HTML allows all valid HTML markup, but Markdown to PDF does not allow all LaTeX.

This is a somewhat surprising difference. All HTML markup I've tried
works well in an Rmarkdown document that aims to go into HTML.
However, not all \LaTeX\ markdown is allowed in an Rmarkdown document
going to PDF. And even less \LaTeX\ code works well if the intended
backend is HTML.  One cannot insert italics with \LaTeX\ in a document
intended for HTML. For example, writing `\emph{italics}` or bold
`\textbf{bold}` in the style of \LaTeX\ code will have no effect in an
HTML document. However, if PDF output is used, then both of those
\LaTeX\ codes work. As evidence, note I get \emph{italics} and bold
\textbf{bold} in this PDF document. 

### Equation Numbering

To designate numbered equations.


<!-- ## Raw HTML -->

<!-- Because this document will eventually be compiled into an HTML file, -->
<!-- we are allowed to insert HTML tags. While the Markdown movement is no -->
<!-- doubt inspired by disappointment with the complicated, unreadable -->
<!-- nature of HTML code, it does not prevent the use of HTML markup -->
<!-- ("markdown" is a play on words, to be the opposite of "markup"). -->
<!-- Rather than the simpler markdown, for example, one might write HTML -->
<!-- <b>bold</b> or <span style="font-weight:bold">bold in another -->
<!-- way</span> in HTML. The HTML markup for these, ```<b>bold</b>``` -->
<!-- or  ```<span style="font-weight:bold">bold in another way</span>``` is -->
<!-- arguably less readable, but it is allowed.  The key point is the -->
<!-- following: If something is unavailable in the Rmarkdown toolkit, one -->
<!-- can directly write with HTML to achieve the purpose. -->

<!-- Using raw HTML markup might be considered a defeat for the would-be -->
<!-- Rmarkdown document writer, but sometimes (perhaps less often now than -->
<!-- a year ago) HTML markup is the only workable option. -->

<!-- The document translation software is surprisingly effective at -->
<!-- converting special characters.  For example, in HTML documents, one -->
<!-- cannot use the less than or greater than symbols in text because they -->
<!-- are markdown separators. In HTML, one would need to insert ```&lt;``` -->
<!-- to represent $<$.  The document conversion programs are aware of this, -->
<!-- however, so that symbols in the markdown file that would ordinarily -->
<!-- "break" the HTML document, like < , >, or &, are gracefully -->
<!-- (automatically) converted to ```&lt;```, ```&gt;``` and ```&amp;```. -->

<!-- Similarly, a forbidden dollar sign in $234.23 would ordinarly crash a -->
<!-- LaTeX document, where one would be required to escape the dollar  -->
<!-- sign, ```\$234.23```, but the Rmarkdown conversion process seems to handle -->
<!-- the un-escaped dollar sign gracefully. -->

<!-- ##Knit (incorporate R code and output) -->


<!-- ### Tables -->

<!-- Here is an example of the rockchalk packages model comparison table -->

<!-- ```{r, warning = FALSE, error = FALSE, message= FALSE,include=FALSE} -->
<!-- library(rockchalk) -->
<!--    set.seed(2134234) -->
<!--    dat <- data.frame(x1 = rnorm(100), x2 = rnorm(100)) -->
<!--    dat$y1 <- 30 + 5 * rnorm(100) + 3 * dat$x1 + 4 * dat$x2 -->
<!--    dat$y2 <- rnorm(100) + 5 * dat$x2 -->
<!--    m1 <- lm(y1 ~ x1, data = dat) -->
<!--    m2 <- lm(y1 ~ x2, data = dat) -->
<!--    m3 <- lm(y1 ~ x1 + x2, data = dat) -->
<!--    gm1 <- glm(y1 ~ x1, family = Gamma, data = dat) -->

<!-- or1 <- outreg(list("Amod" = m1, "Bmod" = m2, "Gmod" = m3), -->
<!-- title = "My Three Linear Regressions", float = FALSE, type = "html", -->
<!-- browse = FALSE) -->
<!-- or1 <- gsub("&nbsp;"," ", or1) -->
<!-- or1 <- gsub("^\\ *", "", or1) -->
<!-- or1 <- paste(or1, collapse = "") -->
<!-- or1 <- gsub("\\ \\ \\ \\ \\ \\ ", " ", or1) -->
<!-- or1 <- gsub("\\ \\ \\ ", " ", or1) -->
<!-- ``` -->

<!-- ```{r,results="asis"} -->
<!-- cat(or1) -->
<!-- ``` -->

<!-- We have settled on Xtable as a great table producing package which offers flexability and functionality. -->

<!-- ```{r, results="asis"} -->
<!--     library(xtable) -->
<!--     or2 <- xtable(summary(m1)) -->
<!--     print(or2, type="html") -->
<!-- ``` -->

<!-- ```{r, results="asis"} -->
<!--     library(psych) -->
<!-- print(xtable(describe(dat)),type = "html") -->
    
<!-- ``` -->

<!-- # Special Features for Rmd into HTML documents. -->

<!-- HTML documents allow for interactivity as compared to other forms of markdown output. Below are some unique features we take advantage of in HTML output. -->


<!-- ## Collored Callouts -->

<!-- Callouts allow the user to specify code chunks, tables, plots, or paragraphs to be collored. This is a great way to get your readers attention. These are always preceded by four # signs. Yes, ####. We stole this idea from other -->
<!-- styles and put them into ours. See usage of {.bs-callout.bs-callout-whatever_you_put here}, where whatever_you_put_here iseither "gray", "red", "orange", "blue", or "green". -->
   
<!-- ```{r, eval=FALSE, include=FALSE} -->
<!-- bscols <- data.frame(old = c("info", "warning", "danger"), -->
<!--                      new = c("blue", "orange", "red")) -->
<!-- ``` -->

<!-- ### Demonstrating Callouts -->

<!-- #### Gray Callout {.bs-callout .bs-callout-gray} -->
<!-- Content here: Gray for wisdom -->

<!-- #### Red Callout {.bs-callout .bs-callout-red} -->
<!-- Red for warnings -->

<!-- #### Orange Callout {.bs-callout .bs-callout-orange} -->
<!-- Orange for examples -->

<!-- #### Blue Callout {.bs-callout .bs-callout-blue} -->
<!-- Blue for right answers -->

<!-- #### Green Callout {.bs-callout .bs-callout-green} -->
<!-- Green for future directions -->


<!-- <\!-- #### R code inside a callout {.bs-callout .bs-callout-red} -\-> -->
<!-- <\!-- ```{r xsummary} -\-> -->
<!-- <\!-- summary(x) -\-> -->
<!-- <\!-- ``` -\-> -->
	  


<!-- ## Interactive Tabs -->

<!-- If you'd like, you can include interactive tabs to HTML reports. Maybe you want to show two similar versions of the same analysis. Or maybe something else. Whatever it may be, be sure to include `{.tabset .tabset-fade}` along with a level 2 header (##). For each tab, put the information under the level 3 header (###). Use another level 2 header to get out of the tabs mode. -->

<!-- The only way (that we know of) to get colors is to wrap the tab headers in a `<span style>` as shown below. This might be useful to draw attention to the tabs. Blue is the default color. -->
<!-- #### What tabs look like {.bs-callout .bs-callout-blue} -->

<!-- ``` -->
<!-- ## You have the ability to include tabs {.tabset .tabset-fade} -->

<!-- If you'd like, you can include different tabs. Maybe you want to show -->
<!-- two similar versions of the same analysis. Or maybe something -->
<!-- else. Whatever it may be, be sure to include `{.tabset .tabset-fade}` -->
<!-- along with a level 2 header (##). For each tab, put the information -->
<!-- under the level 3 header (###). Use another level 2 header to get out -->
<!-- of the tabs mode. -->

<!-- The only way (that we know of) to get colors is to wrap the tab -->
<!-- headers in a `<span style>` as shown below. This might be useful to -->
<!-- draw attention to the tabs. Blue is the default color. -->

<!-- ### <span style="color:red">First Tab Here</span> -->

<!-- Some information you'd like to show. -->

<!-- ### <span style="color:orange">Second Tab Here</span> -->

<!-- Some more information you'd like to show. -->

<!-- Some more information you'd like to show. -->

<!-- ### Third Tab Here -->

<!-- Some final information you'd like to show. -->

<!-- Some final information you'd like to show. -->

<!-- Some final information you'd like to show. -->
<!-- ``` -->

<!-- ## {.tabset .tabset-fade} -->

<!-- ### <span style="color:red">First Tab Here</span> -->

<!-- Some information you'd like to show. -->

<!-- ### <span style="color:orange">Second Tab Here</span> -->

<!-- Some more information you'd like to show. -->

<!-- Some more information you'd like to show. -->

<!-- ### Third Tab Here -->

<!-- Some final information you'd like to show. -->

<!-- Some final information you'd like to show. -->

<!-- Some final information you'd like to show. -->


<!-- ## International characters -->

<!-- Accented letters, often in non-English names, like -->

<!-- Karl Gustav Jöreskog and Dag Sörbom -->

<!-- Linda Muthén and Bengt Muthén -->


<!-- # Policies about writing in these documents. {.bs-callout .bs-callout-red} -->

<!-- 1. Use these callouts to attract attention. -->

<!-- 2. Blank rows separate paragraphs. -->

<!-- 3. The character width of rows should be 80 or less. I have no idea -->
<!-- how anybody thinks they have a right to impose an infinitely long row, -->
<!-- but it's bad. Edit the document with Emacs, run M-q to get -->
<!-- re-positioned text. If your editor cannot do that, quit using it. -->

<!-- 4. Must make sure compiling using the kutils.css located in the crmda -->
<!-- package. For example, `crmda::rmd2html("filename.Rmd")` -->



One major question is what editor will be used. I find the Rstudio
graphical interface to be tedious and frustrating, so I'd never choose
to begin a project that depends on Rstudio.  When I'm using Rstudio, I
often feel that a number of decisions have been taken out of my
control by the designers of the software. In Linux, at least, the
Rstudio program has a number of troublesome quirks, not the least of
which is to destroy the formatting of the YAML prefix in a markdown
document. That has had disastrous consequences in the preparation of
this manuscript.


<!-- [//]: (All guides must have this as the final stanza) -->

<!-- ```{r sessionInfo, echo = FALSE} -->
<!-- sessionInfo() -->
<!-- ``` -->



Available under
[Created Commons license 3.0 <img src="http://crmda.dept.ku.edu/images/cc-3.0.png" alt="CC BY"
style="width: 75px;height: 20px;"/>](http://creativecommons.org/licenses/by/3.0/)

