--- 
title: "CRDMA Guides and Reports"
author:
- affiliation: CRMDA
  description: Director
  email: pauljohn@ku.edu
  name: Paul Johnson
output:
  pdf_document:
    fig_caption: true
    keep_tex: true
    latex_engine: pdflatex
    highlight: haddock
    citation_package: natbib
    pandoc_args: [
        --listings
    ]
    template: theme/crmda-boilerplate.tex
    fontsize: 12pt
preamble:
-  \usepackage{xcolor}
-  \usepackage{amsmath}
-  \usepackage{amssymb}
-  \usepackage{fancybox}
-  \usepackage{calc}
-  \usepackage{subfig}
tables: yes
keywords: guides, report, pandoc, sweave, knitr
---


```{r setup, include=FALSE}
##This Invisible Chunk is required in all CRMDA documents
outdir <- paste0("tmpout")
if (!file.exists(outdir)) dir.create(outdir, recursive = TRUE)
knitr::opts_chunk$set(echo=TRUE,
          comment=NA, fig.path=paste0(outdir, "/p-"))
options(width = 70)
```

\begin{abstract}
This document discusses practical problems with preparation of
technical reports and software guides.  The array of settings may seem
to be overwhelming because there are two formats in which documents
can be prepared, noweb/\LaTeX\ and R markdown (the so-called
"frontends"), two code-chunk processing engines, Sweave and knitr, and
two final output formats, PDF and HTML (the so-called "backends"). In
addition, there are style considerations that differentiate technical
reports and software guides.

This is an R markdown document that uses `knitr` to render R code
chunks. It uses `pandoc` and `pdflatex` as compilers for intermediate
versions of the document. In our vernacular, it is an "rmd2pdf-report"
document. As such, it illustrates some tools that work well in R
markdown documents intended for eventual presentation in PDF
documents. Separate documents will be prepared to illustrate the same
features to be obtained in documents prepared with noweb/\LaTeX
documents and R markdown documents that are compiled into HTML.
\end{abstract}

# Introduction: Terminology


## Backends and frontends

The term **backend** refers to the format of the final presentation of a
document. It is the deliverable format, the end product. The backends
of interest at the present time are

1. `PDF`, the "portable document format"
2. `HTML`, "hypertext markup language"

The term **frontend** refers to the document format that we edit. The
frontends of interest in this document are

1. `Rmarkdown`, a dialect of Markdown that includes R code. Rmarkdown
   files have the suffix (`.Rmd`).
2. `noweb/`\LaTeX, a dialect of \LaTeX which can include R code. The
   suffix for these files is `.Rnw`. We often use the LyX editor and
   store these in `.lyx` files, which are exported to `.Rnw`. 

One might write an Rmarkdown document that is intended for either PDF
or HTML output. A \LaTeX document will generally end up in
PDF. Efforts to create other backends for \LaTeX have met with mixed
success.

In our Center, the backend for reports is always PDF, never HTML. The
backend for guides might be either PDF nor HTML, depending on the
taste of the author.





### We don't always get an error message when we should


Most of the \LaTeX\ markup that we have tested in Rmd files intended
for PDF works well. A good deal of the portion of \LaTeX\ that applies
to math can be used within the Rmd file intended for HTML output. 

I do not currently understand the boundaries, they are no doubt
imposed by the combined converters of `rmarkdown` and `pandoc`.

Similarly, Rmarkdown authors might use HTML code to gain control of
some parts of their document. The compilation process generally *does
not* give error messages when authors make mistakes. Instead, a faulty
HTML document is created.

Authors who use the HTML backend are strongly urged to carefully
proof-read their results to check for "empty space" where features are
expected.

### Keep an eye on `pandoc`

Because the document translation software `pandoc` plays a critical
role in the conversion of documents, the documentation for pandoc will
sometimes give us hints about what is going wrong.  Along those lines,
we point readers to the [Pandoc Markdown reference
manual](http://rmarkdown.rstudio.com/authoring_pandoc_markdown.html). at
the Rstudio website.


# Enter "code chunks"

> A code chunk is a runable piece of R code. Producing the document
> will re-run calculations.

Suppose a professor is writing about the psychology of adolescence or
social conflict in Uganda. In the "old" paradigm, the professor will
do some statistical analysis in SAS or SPSS and the copy/paste output
into the document. This is a tedious, error prone process. Documents
produced in this way are difficult to keep up-to-date and difficult to
proof read.

Instead of cutting and pasting, we instead insert code
chunks that are *run during document preparation*. The advantages of
this are obvious.  The statistical code and results never become "out
of step" with the final document.  If the raw data is revised somehow,
we no longer repeat the "old" fashioned process of re-running the
analysis and then "copy/pasting" the results into a revised
document. Instead, we run through the document preparation steps again
and the results are *automatically* updated and revised.

Code chunks are allowed in both `noweb`/\LaTeX\ and `Rmarkdown` documents
intended for either HTML or PDF. In R, the original method for
creating code is
called ["Sweave"](https://leisch.userweb.mwn.de/Sweave). A code chunk
is created by a somewhat cumbersome notation that begins with "<<>>="
and ends with "@". Here is a code chunk that runs a regression model.

```
<<>>=
lm(y ~ x, data = dat)
@
```

The chunks in `noweb`/\LaTeX\ documents can be processed by `knitr` as
well. In `Rmarkdown` documents, `knitr` is the only chunk-processing
technology that is available. In `Rmarkdown` documents, the outer
boundaries are changed to three back ticks, along with squiggly braces
and the letter "r", which designates the language being processed
(`knitr` can handle several languages).

\begin{lstlisting}
`r ''````{r}
lm(y ~ x, data = dat)
`r ''````
\end{lstlisting}

These are simple, unnamed chunks. In actual usage, the beginning of
the chunk usually has several additional arguments, including a name
for the chunk.  Names are helpful because error messages will later
report the name of the failed chunk.  For that reason, we suggest, as
a general policy, that *chunks should be named*.


```
<<mychunk10>>=
lm(y ~ x, data = dat)
@
```

\begin{lstlisting}
`r ''````{r mychunk10}
lm(y ~ x, data = dat)
`r ''````
\end{lstlisting}

The options, which control if the code is displayed in the document,
or if the output is included, and so forth, can be specified after the
chunk's name.

Rather than going through all possible chunk arguments, we now survey
(and give examples) of the chunk variations that we require in
documents, for any frontend or backend. We need the ability to create
chunks that:

1. are not evaluated, but are displayed "beautifully" to the reader,
   with syntax highlighting.
2. are not displayed, but are evaluated, and the results may (or may
   not) be displayed for the reader.
3. create graphics, which are automatically included in the document.
4. create graphics (or other files) that are not automatically
   included in the document. Graphics are saved in image files that
   can be inserted at a different part in the document
5. import previous chunks for re-analysis.


## Presentable tables

In a report document, it would be unusual to display a large chunk of
R code or output. Instead, reports typically include stylized tables,
graphs, and equations. 

# More about Rmarkdown

See the "Rmarkdown" essay


# Session Info

```{r session}
warnings()
sessionInfo()
```



<!-- [//]: (All guides must have this as the final stanza) -->

<!-- ```{r sessionInfo, echo = FALSE} -->
<!-- sessionInfo() -->
<!-- ``` -->



Available under
[Created Commons license 3.0 <img src="http://crmda.dept.ku.edu/images/cc-3.0.png" alt="CC BY"
style="width: 75px;height: 20px;"/>](http://creativecommons.org/licenses/by/3.0/)

